# 캡슐화

데이터감추기, 데이터를 외부에서 함부로 변경하지 못하도록 외부의 접근을 제한 하는것을 말한다.

캡슐화 없이 모든 값을 public으로 두어 그냥 값을 잘 사용하면 문제 없지 않나? 라는 의문이 있는데, 클래스가 수백개로 많아지면 혼란스럽기 때문에 캡슐화가 필요하다. 더 알아보자.

## 캡슐화의 목적
캡슐화의 목적은 정보의 은닉화이다. 예를들어, 은행이라는 클래스는 잔고라는 변수가 있고 그 잔고를 조회하거나, 잔고를 수정할 수 있는 메서드등이 있다고 가정하자. 잔고라는 변수가 만약 public 으로 선언되어 있다면, 200만원인 나의 잔고가 누군가 접근에 의해 0원이 될 수도이 있다. 따라서 잔고라는 변수는 private로 선언하여 데이터 보호 즉, 정보를 은닉해야 한다. 이렇게 보호된 변수는 getter나 setter등의 메서드를 통해 간접접근이 가능하도록 하는게 캡슐화의 목적이다.

## 캡슐화를 하는 이유

* 문법적 일관성을 제공한다.    
멤버변수를 read하거나 write할 때 데이터의 getter와 setter 함수를 사용한다.
즉, 멤버변수를 사용할때 함수를 사용한다 라는 일관성을 제공한다.
* read만 가능한 멤버변수 write만 가능한 멤버변수 둘다 가능 또는 둘다 불가능한 멤버 변수를 구별해서 제공할 수 있다.
* 구현상의 융통성 증가     
객체를 접근하기 전 어떤 일들을 getter와 setter함수에서 구현할 수 있다. 이러한 점은 코드 중복을 제거해주기도 한다.
* 유지보수 용이    
클래스의 멤버변수와 멤버함수를 공개하는 것은 다른말로 바꾸기(수정하기)쉽지 않다는 의미이다.

예를들어보자

    (Car.java)
    public class Car {
        public string carName;
    }
    (CarTest.java)
    public class CarTest {
        public static void main(String[] args){
            Car c = new Car();
            c.carName = "GranDeur";
            System.out.println(c.carName);
        }
    }

이라는 코드가 있다고 하자. 만약 carName이라는 변수의 이름을 그냥 name으로 바꾸고 싶다고 하면 car클래스의 변수도 수정을 해야하고 CarTest클래스도 수정해주어야 한다.

    (Car.java)
    public class Car {
        private String carName;
        public Car(String name){
            this.carName = name;
        }
        public String getName(){
            return this.carName;
        }
    }
    (CarTest.java)
    public class CarTest {
        public static void main(String[] args){
            Car c = new Car("GranDeur");
            System.out.println(c.getName());
        }
    }

만약 이와 같이 캡슐화를 통해 만든다면, car클래스만 수정하면 된다. 멤버변수뿐만 아니라 멤버함수의 리턴타입, 매개변수의 수정이 발생하면 이를 사용하는 외부의 모든 파일들을 수정해야하는 것이다. 따라서 캡슐화는 유지보수에 용이하다.

# 추상화

추상화에는 데이터 추상화와 추상화가 있다. 추상화는 뒷부분에서 다형성 파트에서 추상클래스나 인터페이스쪽에서 많이 다루므로 데이터 추상화에 초점을 두겠다. OOP에서 추상화란 어떤 구체적인 것에 직접 손대지 않겠다는 의미를 가진다.

## 추상화의 목적
클래스 데이터에 직접 접근을 하지 않고, 세부적인 내용에 대해 모른 채로 함수를 통해서 접근을 하는것이 목적이다.

## 추상화의 장점  
* 추상화를 사용하면 객체가 수행하는 방식 대신 객체가 수행하는 작업에 집중할 수가 있다.
* 코드 중복 방지 및 재사용성 향상(캡슐화와 동일한 이유)
* 사용자에게 영향을 끼치지 않은 채로 독립적으로 클래스의 내부 구현 변경 가능
* 중요한 세부 정보만 사용자에게 제공하므로 응용 프로그램 또는 프로그램이 보안 향상에 도움

