# 프로그램의 유연성?

소프트웨어 분야에서 유연성은 다양한 요구사항을 수용할 수 있는 소프트웨어의 구조적 특성이라고 정의할 수 있다. 소프트웨어는 다른 어떤 컴퓨팅 요소보다도 유연하다. 그리고 **잘 만들어진 소프트웨어일 수록 더 유연하게 요구사항을 수용할 수 있다.**  

소프트웨어의 적용 분야가 확대되고, 소프트웨어 개발 업체들 간에 경쟁이 치열해지고, 더 많은 사람들이 소프트웨어를 사용하게 되고, 더 많은 기기들이 연결되고 더 많은 정보를 수집하게 되면서 **유연성에 대한 요구는 점점 더 증가하고 있다.**  

이러한 요구사항을 반영하기 위해서 소프트웨어는 유연성을 다른 어느 요소보다도 높은 가치로 가지고 갈 수 밖에 없다. 이것이 현대에 객체지향 언어가 대두된 이유이다.  

유연성을 오케스트라에 비유해보자.

![](https://t1.daumcdn.net/cfile/tistory/2438F53A581B2FA72C)

현실 세계에서 서로 다른 다양한 요구사항들을 어떤 방식으로 합리적이고 유연하게 대처하는지를 알게 되었다.   
여러가지 요구사항들을 수집(각 악기 연주자들)하고, 구체적인 요구사항에 비해 다소 추상적인 **공통점(연주자)** 을 찾아내고, 이를 **대상화(연주자라고 부를 수 있도록)** 하고, 이들 공통점에 **차이점을 조금 더하고** (어떤 연주자는 바이올린을 연주한다), 공통점을 중심으로 대상을 다룬다(연주자 여러분 연주하세요)

그럼 유연성을 갖추게 할려면 어떤 단계를 거쳐야 할까?

1. 공통점을 추출한다.( = 차이점을 감춘다.)
2. "대상화" 한다.
3. 차이점을 더한다.
4. 공통점을 통해 대상을 다룬다.

지금까지 배운 객체지향 설계를 생각해보면 무슨 얘기를 하는지 눈치를 챘을 것이다. 

### 추상화(abstraction)

추상화 통해 구체적인 특성을 제거한다.(공통점을 추출한다.)

### 캡슐화(Encapsulation)

1. 공통점들의 묶음에 명칭을 부여한다. 이 "묶음"은 다룰 수 있는 "대상"이 된다.

2. 속성과 행위를 하나로 묶는다.

3. 실제 구현 내용 일부를 은닉한다.

캡슐화라하면, 우선 2번과 3번을 많이 떠올릴 거다. 하지만 중요한 건 1번이다. 명칭이 부여되지 않으면 다룰 수 있는 대상이 되지 못한다. 일반적으로 객체지향에서 이 명칭이라는 것은 타입(Type)이라고 말하고, 대상은 객체를 말한다. 

### 상속(Inheritance)과 다형성(Polymorphism)

상속 통해 다양한 요구사항들에 대해 구현한다. 또, 다형성을 이용함으로써 공통점을 통해 대상을 다룬다. 


# 유연성을 높이기 위해선??

위에서 4가지 객체지향 특성은 유연성을 높인다. 하지만 그 외에는 뭐가 있을까?

## 디커플링
우선 첫 번째로 **디커플링** 이다. 디커플링은 객체들 간 의존성이 강할 때, 인터페이스를 통해 모듈 사이의 의존성을 감소하고 유지보수 효과를 높이는 방법을 말한다. 여기서 유지보수란 변경사항이 생길 경우에 대비한 유지보수를 말한다. 

다 알고 있듯이, 디커플링을 통해 유연성과 재사용성을 높일 수 있다. 유연성에 대해 배우고 왔으니 왜 유연성이 높아지는지 한번 확인해보자. 

디커플링은 위에 말한 4가지 단계를 다 거친다. 인터페이스를 통해 공통점을 추출하고, 인터페이스라는 대상으로 대상화하고, 인터페이스를 구현하는 클래스를 통해 차이점을 더하고, 인터페이스 타입이라는 공통점을 통해 대상을 다룬다. 

하지만, 유연성이 높다고해서 좋은 설계라 할 수 없다. 

**디커플링의 단점**

+ 직관적이지 못할 수 있다.(Robot.java에서 Head.java든 외부의 알고자 하는 부분을 알 수 없다.)
+ 가끔 내부를 알아야 좋은 점도 있다. 
+ 단순한 구조에선 디커플링의 실익이 크지 않다.

그럼, 실용적으로 디커플링을 통해 유연성을 높이는 방법은 어떻게 해야하는 건가.

+ 기본적으로 클래스를 사용한다.
+ 하지만, 다형성 있는 다중 상속이 필요한 경우에는 인터페이스를 사용한다.
+ 변화에 대비할 필요가 있다면 커플링을 줄이려 노력한다. 

고로, 상황에 맞게 적절한 유연성을 지닌 설계가 좋다고 볼 수 있다.

## SOLID 정신
두 번째로는 SOLID 정신이다. SOLID 정신의 목표는 소프트웨어의 설계를 이해하기 쉽고, 유연하고, 유지보가 쉽게 만들기 위해 나온 원칙이다. 하지만, SOLID의 정신의 5가지 원칙을 보면 알겠지만, 매우 추상적인 말이다. 정확히 어느 경우에 어떻게 적용하는지 자세히 설명하지 않는다. 이때문에 SOLID 정신이 요즘 비판을 많이 받고 있다.   
하지만, SOLID 정신을 따른 설계는 유연성이 높아지는 설계인건 부정할 수 없다. SOLID 정신에 대해 알아보자. 

### 단일 책임 정신(Single Responsiblity Principle)

*'소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임만을 가져야 한다.'*

소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임만을 가져야 한다. 다시 말해, 응집도는 높고 결합도는 낮은 프로그램을 뜻한다. 만약 한 클래스가 수행할 수 있는 기능, 즉 책임이 많아진다. 책임이 많아지면 클래스 내부의 함수끼리 강한 결합을 발생할 가능성이 높아진다. 이는 유지보수에 비용이 증가하게 되므로 따라서 책임을 분리시킬 필요가 있다.

### 개방 폐쇄 정신(Open-Closed Principle)

*'기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.'*

이는 클래스 내부 수정없이 동작을 확장할 수 있어야 한다는 의미이다. 상속이 그 좋은 예이다. '상속'과 '다형성'을 같이 써 이 정신을 지키며 확장하는 방법도 있다. 이 정신을 잘 따르면 단일책임정신도 더불어 이룰 가능성이 높다. 

### 리스코프 치환 정신(Liskov Substitution Principle)

*'자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.'*

당연히 지키면 좋은 정신이다. 지키지 않는다면 호출자 코드가 어느 순간 작동 안 할 수 있다. (선언된 자료형만 보면 실제 개체가 뭔지 모르기 때문)

하지만 100% 이렇게 되지는 않는다. 이유는 모든 자식을 알기 전 부모를 완벽히 추상화하는 것은 어려운 일이고, 자식을 추가할 때 부모의 동작을 바꾸는 일이 꽤 있기 때문이다.

### 인터페이스 분리 정신(Interface Segregation Principle)

*'한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다. 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다.'*

디커플링과 매우 유사한 이야기이다. 하지만, 이 정신 또한 극단적으로 가는 것보단 밸런스를 유지하며 정신을 따르는 것이 매우 중요하다. 

### 의존 역전 정신(Dependency Inversion Principle)

*'의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다.'*

즉, 개체끼리 통신할 때 구체적인 것 말고 추상적인 것에 의존하란 이야기이다.  
하지만, 구체적인 것에 의존하면 좋은 상황들 또한 있다. 예를 들어 다형성이 필요하지 않은 상황에서 굳이 인터페이스나 추상 클래스로 결합도를 낮추는 것은 오히려 코드에 악영향을 미친다.

----

위에서 알아봤듯이, SOLID 정신의 5가지 정신 모두 객체지향의 4대 특성을 이용한 설계 방식이라 극단적으로 따르지말고, 상황에 맞게 적절히 사용하면 유연한 설계가 된다고 볼 수 있다. 




## Reference

[https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4-%EC%9C%A0%EC%97%B0%EC%84%B1?category=660012](https://effectiveprogramming.tistory.com/entry/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EC%9D%B4%ED%95%B4-%EC%9C%A0%EC%97%B0%EC%84%B1?category=660012)

[https://xianeml.tistory.com/34](https://xianeml.tistory.com/34)

[https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99](https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99)