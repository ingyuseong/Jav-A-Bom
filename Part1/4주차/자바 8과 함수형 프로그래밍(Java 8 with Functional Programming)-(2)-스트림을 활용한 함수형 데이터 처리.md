# 스트림(Stream)을 활용한 함수형 데이터 처리

## 스트림의 강점(Why Stream?)
대부분의 자바 애플리케이션은 데이터 처리를 위해 컬렉션 프레임워크를 사용한다. 또한, 대부분의 비즈니스 로직은 데이터를 그룹화하여 관리하고, 적절하게 처리하는 작업을 포함하고 있다. 스트림 이전(자바 8 이전)의 경우, 이러한 작업을 수행하는데 다음과 같은 치명적인 문제점이 있다.

* **얻고자 하는 데이터를 코드상에서 명확하게 표현하기 힘들다.**

  이는 선언형으로 데이터를 처리할 수 없음을 의미한다. 예를 들어 유저 데이터 중에서 20살 이상의 유저 데이터를 찾는 연산을 생각해보자. SQL query(선언형 데이터 처리)의 경우 `SELECT name FROM users WHERE age >= 20` 과 같이 원하는 데이터를 코드 상에서 명확하게 표현할 수 있다. 자바 8 이전의 경우, 고전적인 조건, 반복문을 이용하여 작업을 수행하기 때문에 원하는 데이터가 비교적 명확하게 드러나지 않는다.

* 대용량 데이터를 처리할 때, 성능 향상을 위해 멀티코어 아키텍처를 활용해 병렬적으로 각 데이터를 처리한다. 자바 8 이전의 경우 **직접 병렬 처리 코드를 구현해야하는데, 이는 매우 복잡하고 어려운 과정**일 뿐더러, 디버깅도 어렵다.

이러한 문제점을 깔끔하게 해결해줄 수 있는 녀석이 바로 스트림이다. 스트림을 사용하여 컬렉션 **데이터를 SQL query처럼 선언형으로 처리**할 수 있으며, **멀티스레드 코드를 직접 구현하지 않아도 데이터를 투명하게 병렬로 처리**할 수 있다.

스트림에 대해 설명하기 전에, 앞서 글로만 설명했던 스트림의 강점을 예시를 통해 코드 상에서 확인해보자. 선언형 데이터 처리의 강력함을 쉽게 이해할 수 있을 것이다. 전체 유저 데이터에서 20살 이상의 유저 데이터만 뽑아서 나이순으로 정렬한 뒤, 그 유저의 이름을 리스트로 반환해보자. 먼저, 자바 8 이전의 코드이다.

```java
List<User> adultUsers = new ArrayList<>();	// 가비지 변수
for (User user : users) {	// Enhanced for loop과 if를 이용해 조건에 맞는 데이터 추출
	if (user.getAge() >= 20) {
    	adultUsers.add(user);
    }
}
Collections.sort(adultUsers, new Comparator<User>() {	// 익명 클래스로 나이순 정렬
	public int compare(User user1, User user2) {
    	return Integer.compare(user1.getAge(), user2.getAge());
    }
}
List<String> adultUsersName = new ArrayList<>();
for (User user : adultUsers) {	// 다시 한번 반복문을 통해 이름만 추출
	adultUsersName.add(user.getName());
}
```

매우 간단한 로직의 작업임에도 불구하고, **쉽게 읽히지 않는다.** 또한, 위 코드에서 주목할 점은 **가비지 변수**를 정의했다는 것이다. `adultUsers`는 중간변수로써의 용도외에는 쓸모가 없는 가비지 변수이다. 이러한 가비지 변수의 정의가 많아질수록 코드가 복잡해지고, 성능 저하로 이어질 수도 있다. 스트림을 사용한 예시를 보자. 애주 깰끔! 하다.

```java
List<String> adultUsersName = users.stream()	// parallelStream()로 변경가능.
				   .filter(d -> d.getAge() >= 20)	// 조건에 맞는 데이터 추출
                                   .sorted(comparing(User::getAge))	// 나이순 정렬
                                   .map(User::getName)	// 이름만 추출
                                   .collect(toList());	// 리스트로 저장
```

굳이 설명하지 않아도 코드 상에서 선언형으로 데이터를 처리하는 스트림의 강력함을 확인할 수 있을 것이다. 스트림에 더불어 동작 파라미터화까지 더해져 **변하는 요구사항에 유연하게 대응**할 수 있을 뿐만 아니라, `adultUsersName`이 **어떤 데이터를 담고 있는지 코드 상에서 명확하게 드러나고 있다.** 또한, `parallelStream()`을 호출함으로써 **쉽게 멀티코어 아키텍처를 활용할 수 있다.** 위의 예제에서 살펴본 스트림 API의 강점을 정리하면 다음과 같다.

* 선언형 데이터 처리. 코드의 의도가 명확하고, 간결하다. 즉, **가독성이 높다.**
* **간단한 병렬 처리.** 성능 향상.
* 변화하는 문제에 대한 **유연함(동작 파라미터화 사용)**

## 스트림
스트림은 **연속된 데이터의 흐름**같은 개념으로 이해하면 된다. 이런 관점에서 이전의 예제를 살펴보자. 앞서 제시한 스트림을 활용한 코드다.

```java
List<String> adultUsersName = users.stream()	// parallelStream()로 변경가능.
				   .filter(d -> d.getAge() >= 20)	// 조건에 맞는 데이터 추출
                                   .sorted(comparing(User::getAge))	// 나이순 정렬
                                   .map(User::getName)	// 이름만 추출
                                   .collect(toList());	// 리스트로 저장
```

다시 한번 강조한다. 파이프라인을 따라 흐르며, 정해진 연산을 거치는 연속된 데이터의 흐름이다. 위 코드의 경우 스트림 파이프라인은 다음과 같은 구조일 것이다.

![](https://images.velog.io/images/harang/post/ce88cb48-ddd8-4d58-ad66-048a72e84f69/Stream%20Pipeline.png)

위의 그림에서 알 수 있듯이 스트림은 연산끼리 연결하여 데이터가 흐르는 파이프라인을 구성한다. 이 파이프라인은 SQL query와 구조가 흡사하다. 이때, 스트림 연산은 서로 연결되어 파이프라인을 구성하는 **중간 연산**과 마지막에 연결되어 파이프라인을 닫는 **최종 연산**으로 구분된다.

### 중간 연산
중간 연산의 경우 서로 연결되어 파이프라인을 형성한다. 즉, 중간 연산은 다른 스트림을 반환한다. 중간 연산의 핵심 특징은 **[지연(lazy) 처리]()의 방식으로 연산이 수행된다**는 것이다. 즉, 최종 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다. 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 처리하기 때문이다. 다음의 예시를 통해 확인할 수 있다.

```java
import java.util.stream.Intstream;

class LazyOperation {
	public static void main(String[] args) {
    	Intstream.of(1, 3, 5)	// 최종 연산 없음
        	 .peek(d -> System.out.println(d + "\t"));
        System.out.println();
        
        Intstream.of(2, 4, 6)	// 최종 연산 포함
        	 .peek(d -> System.out.println(d + "\t"));
             	 .sum();
        System.out.println();
    }
}

// 출력
//
// 2    4    6
//
```

1, 3, 5로 이루어진 스트림의 경우 최종 연산이 없어 아예 실행되지 않았다. 이러한 지연 처리 덕분에 최적화가 이루어져 성능상 이득을 볼 수 있다. 이외에도 [Short Circuit](), [Loop Fusion]()의 기법으로 효율적으로 데이터를 처리한다.

### 최종 연산
최종 연산은 스트림 파이프라인에서 결과를 도출하며, 종료한다. **즉, 스트림이 아닌 다른 데이터 타입을 결과로써 반환한다.**

이렇게 스트림 연산의 대상이 되는 데이터 소스를 중간 연산과 최종 연산으로 구성된 데이터 파이프라인에 흘려보냄으로써 스트림을 사용할 수 있다. 참고로, 이러한 개념은 [빌더 패턴(Builder Pattern)]()과 비슷하다.

## 스트림과 컬렉션
컬렉션과 스트림 모두 연속된 데이터를 저장하는 자료구조의 인터페이스를 제공한다. 하지만, **데이터를 처리하는 방식**이 다르다. 이는 크게 적극적 생성 vs 지연 생성, 외부 반복 vs 내부 반복의 차이로 볼 수 있다. 이들의 개념적 차이를 자세히 살펴보자

### 영화 다운로드(적극적 생성) vs 넷플릭스(지연 생성)
컬렉션과 스트림의 차이는 영화를 다운로드하여 보는 경우와 넷플릭스에서 보는 경우의 차이로 비유될 수 있다. 당신은 영화를 보고 싶다고 가정하자.

![](https://images.velog.io/images/harang/post/49251d36-1bec-4730-9465-b79aab0ab2a4/image.png)

*영화 파일을 100% 다운로드 하기 전에는 영화를 볼 수 없다..*

첫 번째로 [네이버 시리즈온](https://serieson.naver.com/movie/detail.nhn?viewSeq=56492&prodNo=1398956&isWebtoonAgreePopUp=true)에서 영화를 다운로드받아서 보는 경우, 전체 데이터를 모두 다운로드 받기 전까지 영화를 볼 수 없다. 즉, 컬렉션의 **적극적 생성(모든 값을 계산할 때까지 기다림)**에 비유될 수 있다.

![](https://images.velog.io/images/harang/post/90fd9e84-38f1-40af-aaea-a3e9240beb4a/image.png)

*파란 별을 자세히 보면, 시청 시점에서 일정 부분만 내려받았음을 알 수 있다.*

반면, [넷플릭스](https://www.netflix.com/kr/)에서 바로 보는 경우, 내가 시청하고 있는 부분의 일정 프레임을 내려받음으로써, 대부분의 데이터를 내려받지 않아도 일정 부분 영화를 볼 수 있다. 계속해서 영화를 시청할 경우에만, 이후의 데이터도 시청하는 부분에 따라 내려받아 질 것이다. 이는 **스트림의 지연 생성(필요할 때만 값을 계산)**에 비유될 수 있다.

즉, 데이터를 언제 계산하느냐가 컬렉션과 스트림의 핵심적인 차이다. 다음과 같이 정리된다.

* 컬렉션 : 현재 자료구조가 포함하는 **모든 값을 메모리에 저장하는 자료구조.** 컬렉션에 데이터를 추가하려면 이는 필히 계산된 상태(fully evaluated)여야한다. 적극적 생성.
* 스트림 : 이론적으로 **요청할 때만 데이터를 계산하는 고정된 자료구조.** lazy하게 만들어지는 컬렉션과 같다고 이해하면 된다. 지연 생성.

### 외부 반복 vs 내부 반복
컬렉션을 사용하려면 사용자가 직접 데이터를 반복해야 하며(직접적으로 for loop 사용), 이를 외부 반복이라고 한다. 반면 스트림의 경우, 내부 반복(반복을 내부적으로 알아서 처리)을 사용한다. 즉, 메소드에 어떤 동작을 인자로 넘겨주기만 하면 내부적으로 알아서 그 동작을 반복적으로 처리해준다.

외부 반복의 경우 **병렬성을 직접 관리해야한다**는 치명적인 단점을 가지고 있다. 반면, 내부 반복의 경우 **병렬성을 내부적으로 처리**해줄 뿐만 아니라, **필요에 따라 더 최적화된 순서로 동작을 수행하기도 한다.**


## Reference
* 윤성우의 열혈 Java 프로그래밍(윤성우, 오렌지 미디어, 2017)
* 모던 자바 인 액션(라울-게이브리얼 우르마 외2명, 우정은, 한빛미디어, 2019)