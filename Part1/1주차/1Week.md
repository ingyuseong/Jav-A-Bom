# Java의 자료형
1.  정수형

byte, short, int, long이 있으며, 주로 사용되는 것은 int와 long이다.

    byte(1 byte) < short(2 byte) < int(4 byte) < long(8 byte)

* byte랑 short를 사용하기 보다는 int를 사용하도록하자. byte와 short는 int보다 크기가 작아서 메모리를 좀 더 절약할 수는 있지만, 저장할 수 있는 값의 범위가 작은 편이라서 연산시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다. 그리고 JVM의 피연산자 스택이 피연산자를 4 byte단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 그래서 오히려 int를 사용하는 것이 더 효율적이다.

10진수 외에도 16진수 또는 8진수로 표현된 정수를 변수에 저장할 수 있다. 16진수는 리터럴 앞에'0X'를, 8진수는 '0'을 붙인다.   

    int octNumber = 010;   //8진수 10, 10진수로는 8
    int hexNumber = 0x10;  //16진수 10, 10진수로는 16

* 정수형의 값의 범위는 **-2^(n-1) ~ 2^n-1**이다(n은 bit수). 왜냐 하면 정수형은 0과 1로 이루어진 2진수로 저장된다. 예를 들어 byte 형의 크기가 1byte이고 bit로는 8bit이므로 byte형은 8자리의 2진수로 표현할 수 있다. 정수형은 0을 포함한 양수와 음수를 저장 가능하기 때문에 8자리중 첫번째 자리는 부호자리로 사용된다. 그래서 실제로 값을 표현 할 수 있는 자리수는 모두 7개, 그래서 **-2^7 ~ 2^7-1**이 되는것이다.   

* long타입의 리터럴에는 접미사 'L' 또는 'l'을 반드시 붙여야 한다. 'l'은 숫자1과 혼동되므로 'L'을 사용하자.

* 정수형의 값의 범위가 초과가 되면, 에러가 발생하지는 않지만 최소값부터 다시 반복된다. 예를들어 byte의 경우 최대값이 127인데 128을 저장하려고 하면 -128로 저장된다. (단, 초기화에서는 값의 범위의 초과를 허용하지 않는다.)

2. 실수형

float, double이 있다. 실수는 부동소수점 방식으로 저장된다. 부동 소수점 방식은 실수를 +-a*10^n의 형태로 표현하는 것인데, a는 가수이고 n은 지수이다.(단, a는 0<=a<1인 실수) 예를들어 3.1415를 부동소수점 방식으로 표현하면 0.31415X10 이며 가수는 0.31415이고 지수는 1이다.

    float(4 byte) < double(8 byte)

* float보다 double이 약 두 배의 자리수가 배정되어 있기 때문에 float보다 double의 정밀도(소수점 이하의 자리수)가 더 높은 값을 표현할 수 있다는 것을 알 수 있다.(float은 소수점 이하 7자리까지 표현가능, double은 소수점 이하 15~16자리까지 표현가능)

* float형 리터럴에는 접미사 f가 사용되고, double형 리터럴에는 d(실수의 기본 자료형이기 때문에 생략가능)가 사용된다.

* 실수형 리터럴에 소수점이나 10의 제곱을 나타내는 E 또는 e를 사용할 수 있다.
<pre>
<code>
double d = 0.233E1;
System.out.println(d);

==> 2.33
</code>
</pre>

3. 논리형

boolean 한가지 밖에 없다. true나 false 중 하나를 저장할 수 있기 때문에 1 byte의 크기를 가지고 있고 기본값(default)은 false이다.

4. 문자형

문자형 역시 char 한가지 밖에 없다. C와 다르게 Java에서는 유니코드문자 체제를 사용하기 때문에 크기가 2 byte이다. 16진수로 0000부터 ffff까지, 문자를 표현하는데 65536개(2^16)의 코드를 사용할 수 있으며, char형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다. 예를 들어 알파벳 'A'의 유니코드값은 0041이므로 char형 변수에 문자 'A'를 저장하려면 아래와 같이 한다.

    char c = 'A';
    char c = '\u0041';

주로 첫번째 방법으로 문자를 저장한다. 2 byte인 short와 비교하면 표현할 수 있는 값의 개수는 65536개로 같다. 하지만 char형은 문자의 코드를 저장하므로 음수를 필요로 하지 않기 때문에 2진수로 표현했을 때 첫 번째 자리를 부호에 사용하지 않는다. 따라서 첫 번째 자리를 부호로 사용하지 않는다. 반면에 short형은 첫 번째 자리를 부호를 표현하는데 사용하기 때문에 서로 다른 범위를 갖게 되는 것이다.

* char ch = 'A';가 수행되면 char형 변수 ch에는 문자'A'의 유니코드인 65가 저장된다. 모든 데이터는 숫자로 저장된다. println()은 변수의 값을 출력할 때 변수의 타입이 정수형이면 정수값을 그대로 출력하고 char형이면 정수값에 해당하는 문자를 찾아서 출력한다.

* char tab = '\t'; 와 같이 tab이나 backspace 등의 특수 문자를 저장할 수 있다.

# 다차원 배열
2차원 배열의 선언방법은 타입[][] 변수이름; , 타입 변수이름[][];, 타입[] 변수이름[];이 있다(3차원 이상도 차원의 수만큼 []를 추가 해주면 된다.).첫번째[]는 열, 두번째[]는 행을 나타낸다. 따라서 테이블 형태의 데이터를 담는데 사용된다.

* 다차원 배열(배열의 배열)은 가변배열이다.   
예를 들어, int[][] score = new int[5][3];의 코드를 다음과 같이 표현 할 수 있다.

<pre>
<code>
int[][] score = new int[5][];
score[0] = new int[3];
score[1] = new int[3];
score[2] = new int [3];
score[3] = new int [3];
score[4] = new int [3];
</code>
</pre>

이 원리를 이용하여 다음과같은 배열을 생성하는것도 가능하다.
<pre>
<code>
int[][] score = new int[5][];
score[0] = new int[4];
score[1] = new int[3];
score[2] = new int [2];
score[3] = new int [2];
score[4] = new int [3];
</code>
</pre>
중괄호를 통해서도 생성과 초기화를 동시에 하는것이 가능하다.
<pre>
<code>
int[][] score = {
    {100, 100, 100, 100},
    {20, 20, 20},
    {40, 40, 40},
    {50, 50, 50}
};
</code>
</pre>

아래의 코드는 다차원 배열을 이용한 마방진을 만든 예이다.

<pre>
<code>
public class MagicSquareTest {

	public static void main(String[] args) {
		int[][] data = new int[5][5];
		
		int i=0, j=2;
		for(int k=1;k<=Math.pow(5, 2);k++) {
			data[i][j] = k;
			if(k%5 == 0) {
				i++;
			}else {
				i--;
				j++;
				 if(i<0) {
					i=4;
				}
				 if(j>=5) {
					j=0;
				}
			}
		}
				
		for(int i=0;i < data.length;i++) {
			for(j=0;j < data[i].legnth;j++){
				System.out.printf("%2d ",data[i][j]);
			}
			System.out.println();
		}
	}
}
</code>
</pre>