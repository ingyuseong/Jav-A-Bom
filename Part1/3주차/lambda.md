# 람다(Lambda)
람다식은 자바에서 제공하는 함수형 프로그래밍 방식이다. 람다식의 문법은 `(매개변수) -> {실행문;}`과 같다. 람다식 문법에서는 매개변수 자료형을 생략할 수 있다.

![](https://t1.daumcdn.net/cfile/tistory/99E953335A2006A005)


## 함수형 프로그래밍(FP : Functional Programming)
함수형 프로그래밍은 순수 함수(pure function)을 구현하고 호출함으로써 외부 자료에 부수적인 영향을 주지 않도록 구현하는 방식이다. 순수 함수란 매개변수만을 사용하여 만드는 함수다. 즉 함수 내부에서 함수 외부에 있는 변수를 사용하지 않아 함수가 수행되더라도 외부에 영향을 주지 않는다. 

> #### 함수형 프로그래밍의 장점
+ 함수가 입력받은 자료 이외에 외부 자료에 영향을 미치지 않기 때문에 여러 자료 동시에 처리하는 병렬 처리에 적합하며, 안정되고 확장성 있는 프로그램을 개발할 수 있다는 장점이 있다. 
+ 순수 함수로 구현된 함수형 프로그램은 함수 기능이 자료형에 독립적일 수 있도록 보장한다. 즉 동일한 입력에 대해서는 동일한 출력을 보장하고, 다양한 자료에 같은 기능을 수행할 수 있다.


람다식은 메서드 이름이 없고 메서드를 실행하는데 필요한 매개변수와 매개변수를 활용한 실행코드를 구현한 것입니다. 메서드는 어디에 선언하고 구현하나??  
함수형 언어에서는 함수만 따로 호출할 수 있지만, 자바에서는 참조 변수 없이 메서드를 호출할 수 없다. 따라서 람다식을 구현하기 위해, 함수형 인터페이스를 만들고, 인터페이스에 람다식으로 구현할 메서드를 선언한다.  

### 타겟 타입과 함수형 인터페이스
자바는 메서드를 단독으로 선언할 수 없고 항상 클래스의 구성 멤버로 선언하기 때문에 람다식은 단순히 메서드를 선언하는 것이 아니라 이 메서드를 가지고 있는 개체를 생성해낸다. 어떤 타입의 개체를 생성하나?  
람다식은 인터페이스 변수에 대입된다. 이 말은 람다식은 인터페이스의 익명 구현 개체를 생성한다는 뜻이다. 인터페이스는 직접 개체화할 수 없기 때문에 구현 클래스가 필요한데 람다식은 익명 구현 클래스를 생성하고 개체화한다. 람다식은 대입될 ***인터페이스의 종류에 따라 작성 방법이 달라지기 때문에*** 대입될 인터페이스를 람다식의 타겟 타입(target type)이라고 한다.
> 함수형 인터페이스에서 선언한 ***메서드의 종류(매개변수와 리턴값의 유무)***에 따라 람다식이 어떻게 쓰일지 바뀐다는 의미이다.

### 익명 구현 개체과 익명 (자식) 개체
우선은 익명 개체에 대해 알아보자면, 익명 개체는 이름이 없는 개체를 의미한다. 익명 개체는 단독으로 생성될 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. 익명 개체는 필드의 초기값이나 로컬 변수의 초기값, 매개변수의 매개값으로 주로 대입된다. 
익명 자식 개체에 대해 알아보자면, 상속을 받은 자식 클래스가 재사용되지 않고, 오로지 부모클래스의 해당 필드와 변수의 초기값으로만 사용할 경우라면 익명 자식 객체를 생성해서 초기값으로 대입하는 것이 좋은 방법이다.
	
	class A {
		Parent field = new Parent() {
			int childField;
			void childMethod() {}
			@Override
			void parentMethod() {}
		};
	}

중괄호{} 내부가 익명 자식 개체가 된다. 중괄호 내부에서 필드나 메서드를 선언하거나 부모 클래스의 메서드를 재정의하는 내용이 온다. 여기서 일반 클래스와의 차이점은 생성자를 선언할 수 없다는 것이다. 또한, 익명 자식 객체에 새롭게 정의된 필드와 메서드는 익명 자식 개체 내부에서만 사용디고 외부에서는 필드와 메서드에 접근할 수 없다. 재정의한 메서드는 접근 가능.

이제 익명 구현 개체에 대해 알아보자면, 익명 구현 개체는 익명 자식 개체와 개념이 비슷하다. 하지만 인터페이스 타입으로 선언한다는 것이 차이점이다.

	class A {
		RemoteControl field = new RemoteControl() {		//RemoteControl : interface
			@Override
			void turnOn() {...}
		};
	}
 
## 익명 객체를 생성하는 람다식
자바는 OOP언어이다. 하지만 람다식은 개체 없이 인터페이스의 구현만으로 메서드를 호출할 수 있다. 자바는 개체 생성없이 메서드 호출이 일어날 수 없는데 메서드는 어떻게 호출되는 것인가?  
> 밑의 코드는 Runnable 인터페이스의 익명 구현 개체를 생성하는 전형적인 코드다. 
> ![](https://t1.daumcdn.net/cfile/tistory/997DA6335A20050E27)   
> 람다식은 함수 정의 형태를 띠고 있지만 런타임 시에는 인터페이스의 익명 구현 개체로 생성된다. 어떤 인터페이스를 구현할 것인가는 대입되는 인터페이스가 무엇이냐에 달려있다. 위 코드에서 람다식은 Runnable의 익명 구현 개체를 생성한다. 

즉 람다식으로 구현해서 호출하면 컴퓨터 내부에선 다음처럼 익명 클래스가 생성되고 이를 통해 익명 개체가 생성되는 것이다. 

	StringConcat concat3 = new StringConcat(){
		@Override
		public void makeString(String s1, String s2) {
			System.out.println(s1 + "," + s2);
		}
	};
		

### @FunctionalInterface 애노테이션
모든 인터페이스를 람다식의 타겟타입으로 사용할 수는 없다. 람다식이 하나의 메서드를 정의하기 때문에 두 개 이상의 추상 메서드가 선언된 인터페이스는 람다식을 이용해서 구현 개체를 생성할 수 없다. 하나의 추상 메서드가 선언된 인터페이스만이 람다식의 타겟 타입이 될 수 있다.이러한 인터페이스를 함수형 인터페이스라 한다. **함수형 인터페이스를 작성할 때 두 개 이상의 추상 메서드가 선언되지 않도록 컴파일러가 체킹해주는 기능**이 있는데, 인터페이스 선언 시 **@FunctionalInterface 애노테이션**을 붙이면 된다.  
이 애노테이션은 두 개 이상의 추상 메서드가 선언되면 컴파일 오류를 발생시킨다. 또, 이 애노테이션은 반드시 써야하는 것은 아니지만, 함수형 인터페이스라는 것을 명시적으로 표현할 수 있으므로 나중에 발생할 오류를 방지할 수 있다. 


### 람다식에서 사용하는 클래스 멤버와 로컬 변수
람다식의 실행 블록에는 클래스의 멤버(필드와 메서드) 및 로컬 변수를 사용할 수 있다. 클래스의 멤버는 제약 사항 없이 사용이 가능하지만, 로컬 변수는 제약 사항이 따른다.
#### 클래스의 멤버 사용
위에서 얘기했듯이 제약 사항 없이 사용할 수 있다. 하지만 **this 키워드**를 사용할 때에는 주의가 필요하다. 일반적으로 익명 개체 내부에서는 this는 익명 개체의 참조이지만, 람다식에서 this는 내부적으로 생성되는 익명 개체의 참조가 아니라 람다식을 실행한 개체의 참조이다. 아래의 예제를 통해 람다식에서 바깥 개체와 내부 개체의 참조를 얻어 필드값을 출력하는 방법을 보여주고 있다. 내부 개체 Inner에서 람다식을 실행했기 때문에 람다식 내부에서의 this는 내부 개체 Inner이다.

인터페이스 선언

	@FunctionalInterface
	public interface MyFunctionalInterface {
		public void method();
	}
this 사용

	public class UsingThis {
		public int outterField = 10;
		
		class Inner {
			int innerField = 20;

			void method() {
				MyFunctionalInterface fi = () -> {
					System.out.println("outterField : " + outterField);
					System.out.println("outterField : " + UsingThis.this.outterField);  	
																	
					System.out.println("innerField : " + innerField);					
					System.out.println("innerField : " + this.innerField);
				};
				fi.method();

			}
		}
	}
Test

	UsingThis usingThis = new UsingThis();
	UsingThis.Inner inner = usingThis.new Inner();
	inner.method();

실행결과

	outterField : 10
	outterField : 10
	innerField : 20
	innerField : 20

#### 로컬 변수 사용
예를 들어 람다식 안에서 main함수 내부에 있는 지역 변수를 변경하려 한다면 어떻게 될까?  
컴파일 오류가 난다.   
하지만 변경하지 않고 변수 값 그대로 쓰는 경우는 오류가 발생하지 않는다. 이유는?  

람다식은 메서드 내부에서 주로 작성되기 때문에 로컬 익명 구현 개체를 생성시킨다고 봐야 한다. 람다식에서 바깥 클래스의 필드나 메서드는 제한없이 사용할 수 있으나, 메서드의 매개 변수 또는 로컬 변수를 사용하면 이 두 변수는 final 특성을 가져야 한다. 왜 fianl 특성을 가져야할까?
> 이유는 익명 개체가 로컬 변수를 사용하는 것에서 이해해보자. 익명 개체 내부에서는 바깥 클래스의 필드나 메서드는 제한없이 사용가능하다. 문제는 메서드의 매개변수나 로컬 변수를 익명 개체에서 사용할 때 이다. 메서드 내에서 생성된 익명 개체는 메서드 실행이 끝나도 힙 메모리에 존재해서 계속 사용할 수 있다. 매개 변수나 로컬 변수는 메서드 실행이 끝나면 스택 메모리에서 사라지기 때문에 익명 개체에서 사용할 수 없게 되므로 문제가 발생한다.  
>  **지역 클래스(로컬 클래스)에서 사용된 매개 변수와 로컬 변수는 모두 final 특성을 가진다.** 똑같은 구조로 익명 개체의 내부에서 메소드의 매개 변수나 로컬 변수를 사용할 경우, 이 변수들은 final 특성을 가져야한다. 자바7 이전에는 final을 명시해야했지만, 자바 8이후부터는 final 키워드 적지 않아도 여전히 값을 수정할 수 없는 final 특성을 갖는다.



참고

+ https://pridiot.tistory.com/52?category=869931
+ 이것이 자바다
+ do it 자바 프로그래밍
+ https://kkk-kkk.tistory.com/entry/JAVA-chapter14-%EB%9E%8C%EB%8B%A4%EC%8B%9D-141-%EB%9E%8C%EB%8B%A4%EC%8B%9D%EC%9D%B4%EB%9E%80-142-%EB%9E%8C%EB%8B%A4%EC%8B%9D-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-143-%ED%83%80%EA%B2%9F-%ED%83%80%EC%9E%85%EA%B3%BC-%ED%95%A8%EC%88%98%EC%A0%81-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4
