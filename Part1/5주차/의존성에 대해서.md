# 의존성
지금 강의를 대략 15시간 이상 들으면서, 좀 붕뜨는 이야기가 많고 구체적으로 정리가 잘 되지 않는다는 느낌을 받았었다. 근데 이번 섹션 13의 강의를 들으며, 예전에 명쾌하게 이해되지 않았던 부분들이 꽤 많이 연결되고 정리된 느낌이다. 너무 좋았다. 이번 섹션. 항상 강의만으로는 부족하다고 생각되어 주제에 대해 강의 이상의 소스를 찾아서 정리하곤 했는데, 이번에는 강의가 너무 괜찮아서 강의내용만을 정리하며, 다시 한번 개념을 정리해보고자 한다.

*해당 개념에 관해서 객관적인 정답을 제시하는 글이 아니고 정확히 말하면 정답이 없다고 생각합니다. 실제 현업 개발자들 사이에서도 Controversial한 부분이고요. 다만, Pope님이 강의하신 Majority의 주장을 공부하고, 제가 주관적으로 받아들인 부분을 정리해봤습니다.*

## 의존성의 개념
의존성(dependency)과 결합도(coupling)라는 Terminology에 대한 잘못된 이해 혹은 혼용 등으로 다소 그릇된(다고 여겨지는) 주장을 하는 분들이 많다고 한다. 이 개념을 처음 접하는 만큼, 일단 간단하게 이해해보자. 참고로, 엄밀히 말하면 정확한 개념은 아니지만, 현재는 이렇게 받아들이자.

> ***A가 B에 의존한다. = B의 코드를 변경 시, A의 코드도 변경해야하는 경우.***

### 의존성이 있으면 잘못된 설계다?
위와 같은 주장을 하는 분들이 있다. 그러나, 단순하게 의존성이 있다고 그 설계가 잘못되었다고 볼 수 없다. 오히려, 적절한 의존성이 있어야 좋은 설계다. 적절한 의존성을 가진다는 것은 다음을 의미한다.

* 각 클래스의 목적이 뚜렷하다.
* 캡슐화가 잘 이루어져있다는 의미.
* 클래스를 재사용할 수 있다는 의미.

앞서 말했듯이 많은 사람들이 Terminology를 정확하게 이해하지 못하고 있어 위와 같은 주장을 한다고 한다. 자세한 사항은 직접 [강의](https://www.udemy.com/course/object-oriented-programming-and-design-by-pocu/learn/lecture/19664290#overview)를 참고하자. 우린 용어의 좀 더 정확한 의미를 알아보는데 집중하겠다.

## 결합도와 의존성
이 또한, 간단하게 정리하자면 다음의 기준을 근거로 이해할 수 있다.

> ***A가 B에 의존할 때, B의 코드를 변경할 경우 프로그램이 제대로 작동하는가?***

* A의 코드를 변경하지 않아도 제대로 동작함!
  * A depends lightly on B
  * 낮은 결합도(Loose Coupling)를 가진다.
* A의 코드를 변경해야만 제대로 동작함!
  * A depends heavily on B
  * 낮은 결합도(Tight Coupling)를 가진다.

## 의존성 주입(Dependency Injection)
이를 줄여서 DI라는 용어로 많이 사용하는데, 이 DI라는 용어 자체가 DI Container, Dependency Inversion등을 의미하기도 하기 때문에 헷갈리기 쉬운 개념이다. 따라서, 이번에도 엄밀하게 말하면 정확하진 않지만, 쉽고 간결하게 개념을 이해해보자. 다음과 같이 이해하면 무난하다.

> ***클래스 내에서 직접 개체를 생성하여 참조하지 않고, 파라미터로 전달 받아 참조받게 하는 것.***
>
> 의존하고 있는 클래스를 파라미터로 주입한다! 라는 뜻으로 받아들이자.

이때, 파라미터의 참조형이 추상적일수록(상위 클래스일수록) 의존성은 낮아진다.

### 의존성 주입의 득과 실
| 득    | 실 |
| ----------- | ----------- |
| 결합도를 낮춤(디커플링).      | 코드를 통해 프로그래머의 원래 의도를 표현하기 힘들어짐(코드가 직관적이지 못함).  |
| 변화에 대해 유연하게 대처할 수 있음.   | 단위가 작은 인스턴스도 직접 생성해야함(편의성 감소). |

이러한 트레이드 오프를 고려하여, 무조건적인 디커플링을 지양하고, 상황에 맞는 적절한 판단을 하는 게 중요하다. 다음의 기준을 통해 디커플링이 적합한 경우인지 판단해보자.

* 단순한 구조의 경우 부적합하다.
  * 대부분 컴파일 에러를 발생시키므로 디버깅이 어렵지 않음.
* 즉, 복잡할수록, 대규모 프로젝트일수록 적합하다.
  * 변화에 대한 유연한 대처의 장점이 극대화됨.
* 결론적으로, 변경을 하면 안되는(하기 힘든) 클래스의 경우 디커플링하는 게 좋다.

## 어떻게 의존성을 활용할 것인가?
지금까지 간단하게 개념을 정의했고, 살펴보았다. 마지막으로 이를 어떻게 OOAD에 적용할 것 인가에 대해 다루고자 한다. 이 또한, 주관성이 매우 강한 부분이고 상황에 따라 천차만별이기 때문에 일률적으로 특정한 정답을 따르라는 것은 어불성설이다. 다만, 입문자 입장에서는 다음과 같은 정도의 기준을 토대로, 다양한 경험을 통해 본인만의 답을 정의해나가면 되지 않을까 싶다.

> *"Programming to an Interface, not an Implementation."*
>
> 이때, Interface는 자바의 Interface가 아니라 일반적인 개념의 Interface이다.
> 즉, 핵심은 다형성을 가진 일반적(추상적) 메소드 시그내처를 정의하는 것이다.

뭐 문장 자체가 워낙 추상적이라 쉽게 이해가 안될 수도 있으나, 내가 이해한 바로는 다음과 같이 의존성/디커플링에 대한 개념을 간단하게 정리하면 될 것 같다.

> ***구체적인(자식) 클래스의 메소드에 의존하지말고, 추상적인(부모) 클래스의 다형적 메소드에 의존해라.***

추가적으로, 다음과 같이 이전에 깔끔하게 풀리지 않고, 애매하게 이해하고 넘어간 개념들 중 상당수가 이번 강의를 통해 명확하게 해결되었다. 혼자 *이게 맞는 거 아닐까..?* 라고 생각만 하고 있던 개념들을 Instructor가 *ㅇㅇ 그게 맞음*이라고 검증해준 느낌이다.
![](https://images.velog.io/images/harang/post/7cb09b02-8440-4ed6-b597-701fe94095bf/image.png)

![](https://images.velog.io/images/harang/post/308f02bd-098b-4e68-a6bb-763f0cb760d4/image.png)

## Reference
[개체지향 프로그래밍 및 설계 섹션 13: 인터페이스 vs 구현](https://www.udemy.com/course/object-oriented-programming-and-design-by-pocu/learn/lecture/19664290#overview)