# 추상 클래스/메서드

추상 클래스는 실체 클래스의 공통적인 부분을 추출하여 만든 클래스이며 독자생존이 불가능한 클래스이다.

## 추상 클래스를 왜 사용할까?

1. 공통된 필드와 메서드를 통일한 목적

10명 개발자에게 자동차를 상속받아 각자만의 실체클래스를 구현하라고 주문해보자.

10명 개발자가 생각한 변수명과 메서드명은 제각기 다른 이름을 가지고 구현될 것이다. 이렇게 구현이 되면 문제가 있다. 만약, 수만줄에 이르는 코드에 A라는 자동차 실체클래스 객체를 선언하고 해당 객체의 필드와 메서드를 떡칠했다고 치자. 헌데, A자동차가 계약만료되고, B자동차를 새로 교체해야한다고 하자....응?

느낌이 오는가? 만약 B자동차의 변수와 메서드명이 A자동차와 동일하면 객체 인스턴스만 변경하면 되는데, 필드와 메서드를 전부다 체크해서 변경해줘야한다. 유지보수는 개뿔 이건 아예 새로 개발하는 느낌일 것이다. 따라서 '자동차'라는 추상클래스를 만든다! 즉, 추상클래스에서 미리 정의한 필드와 메서드가 있다면, 실체클래스는 추상클래스의 필드와 메서드명을 변경할 수 없고 무조건 해당 명명으로 구현해야한다. 따라서, 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다.

여기서 추상클래스가 아니라 일반 클래스로 만들고 A,B로부터 상속받게하여 오버라이딩 하면 되지 않나? 라는 생각이 들 수 있다. 하지만 자동차 라는 클래스는 독자생존이 가능할까? 자동차라는 인스턴스를 만든다고 하여도 쓸모가 없고, 추상적이다. 구체적인 무슨 자동차인지 모르는 그런 존재이므로 독자생존이 불가능하다고 판단된다. 따라서 추상클래스로 만드는것이다.

2. 실체클래스 구현시, 시간절약

실무적으로 생각해보자! 나는 SI개발자이다. 헌데 시간이 겁나 없다 빨리 개발해야하는데.. 갑자기 나보고 자동차라는 어마무시한 클래스를 일주일 안에 구현하라고한다. 그럼 설계부터 생각한다. 음..자동차는 바퀴가 있어야하고, 굴러가야하고 아 맞어 백미러도 있어야하고...트렁크도 있어야하고 ...응?

느낌이 오는가? 여기서 추상클래스는 효과를 발휘한다. 내가 자동차를 구현해야하는데, 자동차 추상클래스를 상속받으면, 자연스럽게 자동차에 공통적으로 들어가야하는 필드와 메서드가 녹여져있는 필드와 메서드가 똭 하고 오버라이딩 된다. 즉, 강제로 주어지는 필드와 메서드를 가지고 나만의 스타일대로 구현만 하면 된다. 설계 시간이 절약된다..구현하는데만 집중할 수 있다!! (실제로 취업하면 추상클래스를 설계해야 하는 일은 없고 추상클래스는 다른 개발자 AA(aplication architecture)가 설계해준다고 한다.)

## 추상 클래스의 작성

추상화를 구체화와 반대되는 의미로 이해하면 보다 쉽게 이해할 수 있을 것이다. 상속계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화의 정도가 심해지며, 상속계층도를 따라 올라갈수록 클래스는 추상화의 정도가 심해진다고 할 수 있다. 즉, 상속계층도를 따라 내려 갈수록 세분화되며, 올라갈수록 공통요소만 남게 된다.

추상 클래스의 예시

    abstract class player {
        boolean pause;
        int currentPos;

        Player() {
            puase = false;
            currentPos = 0;
        }

        abstract void play(int pos);

        abstract void stop();

        void play() {
            play(currentPos);
        }

        void pause() {
            if(pause) {
                pause = false;
                play(currentPos);
            } else {
                pause = true;
                stop();
            }
        }
    }

    class CDPlayer extends Player {
        void play(int currentpos) {
            ...
        }
        
        void stop() {
            ...
        }

        int currentTrack;

        void nextTrack() {
            currentTrack++;
            ...
        }

        void preTrack() {
            if(currentTrack > 1) {
                currentTrack --;
            }
            ...
        }

    }

추상클래스는 클래스명앞에 abstract를 붙이면 되고, 추상메서드도 똑같다. 추상클래스를 상속받는 클래스는 추상 메서드를 오버라이딩을 하여 구현을 해줘야 한다. 따라서 CDPlayer클래스는 play추상메서드와 stop추상메서드를 오버라이딩하여 구현했다.

사실 Player클래스의 play(int pos)와 stop()을 추상메서드로 하는 대신, 아무 내용도 없는 메서드로 작성할 수도 있다. 아무런 내용도 없이 단지 괄호{}만 있어도, 추상메서드가 아닌 일반 메서드로 간주되기 때문이다.

    class Player {
        ...
        void play(int pos) {}
        void stop() {}
        ...
    }

어차피 자손 클래스에서 오버라이딩하여 자신의 클래스에 맞게 구현할 테니 추상메서드로 선언하는 것과 내용없는 빈 몸통만 만들어 놓는 것이나 별 차이가 없어 보인다.

그래도 abstract를 붙여 추상메서드로 선언 하는 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다. 만일 추상메서드로 정의되어 있지 않고 위와 같이 빈 몸통만 가지도록 정의되어 있다면, 상속받는 자속 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있기 때문이다.


# 참고
* https://limkydev.tistory.com/188
* 자바의 정석